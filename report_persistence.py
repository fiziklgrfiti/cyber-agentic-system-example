#!/usr/bin/env python3
"""
Report Persistence System for Security Capability Measurement Program

This module implements a unified report persistence system for storing and
retrieving reports generated by any agent in the system.
"""

import os
import re
import time
import json
import logging
import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

logger = logging.getLogger('security_measurement')

class ReportPersistenceSystem:
    """
    Unified system for persisting and retrieving reports from all agents.
    Stores reports in Markdown format with organized directory structure.
    """
    
    def __init__(self, base_dir: str = "data/reports"):
        """
        Initialize the report persistence system.
        
        Args:
            base_dir: Base directory for storing reports
        """
        # Add instance tracking to detect multiple instantiations
        import traceback
        stack = traceback.extract_stack()
        caller = stack[-2]  # Get the caller info
        logger.debug(f"ReportPersistenceSystem being initialized from: {caller.filename}:{caller.lineno}")
    

        self.base_dir = Path(base_dir)
        
        # Create report directories
        os.makedirs(self.base_dir, exist_ok=True)
        
        # Create report type directories
        self.report_types = {
            "inventory": self.base_dir / "inventory",
            "measurement": self.base_dir / "measurement",
            "analysis": self.base_dir / "analysis",
            "executive": self.base_dir / "executive",
            "technical": self.base_dir / "technical",
            "compliance": self.base_dir / "compliance",
            "trend": self.base_dir / "trend",
            "other": self.base_dir / "other"
        }
        
        # Create directories for each report type
        for dir_path in self.report_types.values():
            os.makedirs(dir_path, exist_ok=True)
        
        # Create index file
        self.index_file = self.base_dir / "index.json"
        self._load_or_create_index()
        
        logger.info(f"Report persistence system initialized in {base_dir}")
    
    def _load_or_create_index(self):
        """Load or create the report index file."""
        if self.index_file.exists():
            try:
                with open(self.index_file, 'r') as f:
                    self.index = json.load(f)
                logger.debug("Report index loaded")
            except Exception as e:
                logger.error(f"Error loading report index: {str(e)}")
                self._create_empty_index()
        else:
            self._create_empty_index()
    
    def _create_empty_index(self):
        """Create an empty report index."""
        self.index = {
            "last_updated": datetime.datetime.now().isoformat(),
            "report_count": 0,
            "reports_by_type": {report_type: [] for report_type in self.report_types.keys()},
            "reports_by_agent": {},
            "reports": {}
        }
        self._save_index()
        logger.debug("Created new report index")
    
    def _save_index(self):
        """Save the report index to disk."""
        self.index["last_updated"] = datetime.datetime.now().isoformat()
        
        try:
            with open(self.index_file, 'w') as f:
                json.dump(self.index, f, indent=2)
            logger.debug("Report index saved")
        except Exception as e:
            logger.error(f"Error saving report index: {str(e)}")
    
    def _sanitize_filename(self, text: str) -> str:
        """
        Sanitize text for use as a filename.
        
        Args:
            text: Text to sanitize
            
        Returns:
            Sanitized text
        """
        # Replace spaces with underscores and remove non-alphanumeric characters
        sanitized = re.sub(r'[^\w\s-]', '', text).strip().lower()
        sanitized = re.sub(r'[-\s]+', '_', sanitized)
        
        return sanitized
    
    def _determine_report_type(self, title: str, agent_id: str) -> str:
        """
        Determine the report type based on title and agent ID.
        
        Args:
            title: Report title
            agent_id: ID of the agent that generated the report
            
        Returns:
            Report type
        """
        title_lower = title.lower()
        
        # Check for analysis report types
        if "executive" in title_lower or "summary" in title_lower:
            return "executive"
        elif "technical" in title_lower or "detailed" in title_lower:
            return "technical"
        elif "compliance" in title_lower or "regulatory" in title_lower:
            return "compliance"
        elif "trend" in title_lower or "forecast" in title_lower:
            return "trend"
        
        # Check for agent-based types
        if "inventory" in agent_id.lower():
            return "inventory"
        elif "measurement" in agent_id.lower():
            return "measurement"
        elif "analysis" in agent_id.lower():
            return "analysis"
        
        # Default to other
        return "other"

    def store_report(self, content: str, title: str, agent_id: str, report_type: Optional[str] = None, 
                    metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Store a report in the persistence system.
        
        Args:
            content: Report content in Markdown format
            title: Report title
            agent_id: ID of the agent that generated the report
            report_type: Optional explicit report type
            metadata: Optional additional metadata
            
        Returns:
            ID of the stored report
        """
        logger.info(f"Attempting to store report: {title} from agent {agent_id}")
        
        # Generate report ID based on timestamp and sanitized title
        timestamp = int(time.time())
        sanitized_title = self._sanitize_filename(title)
        report_id = f"{timestamp}_{sanitized_title}"
        
        try:
            # Determine report type if not specified
            if not report_type:
                report_type = self._determine_report_type(title, agent_id)
            
            # Ensure report type is valid
            if report_type not in self.report_types:
                logger.warning(f"Unknown report type '{report_type}', using 'other'")
                report_type = "other"
            
            # Create metadata if not provided
            if metadata is None:
                metadata = {}
            
            metadata.update({
                "title": title,
                "agent_id": agent_id,
                "report_type": report_type,
                "generated_at": datetime.datetime.now().isoformat()
            })
            
            # Create the report file
            report_dir = self.report_types[report_type]
            report_file = report_dir / f"{report_id}.md"
            
            logger.debug(f"Preparing to write report to: {report_file}")
            logger.debug(f"Report content length: {len(content)} characters")
            
            # Add front matter to markdown content
            front_matter = "---\n"
            for key, value in metadata.items():
                front_matter += f"{key}: {value}\n"
            front_matter += "---\n\n"
            
            full_content = front_matter + content
            
            # Ensure the directory exists
            report_dir.mkdir(parents=True, exist_ok=True)
            
            # Check if we have write permissions
            if not os.access(report_dir, os.W_OK):
                logger.error(f"No write permission for directory: {report_dir}")
                return ""
            
            # Write the file with explicit error handling
            try:
                with open(report_file, 'w') as f:
                    f.write(full_content)
                logger.info(f"Successfully wrote report file to {report_file}")
            except PermissionError as pe:
                logger.error(f"Permission error writing to {report_file}: {str(pe)}")
                return ""
            except IOError as io_err:
                logger.error(f"IO error writing to {report_file}: {str(io_err)}")
                return ""
            except Exception as e:
                logger.error(f"Unexpected error writing report file to {report_file}: {str(e)}", exc_info=True)
                return ""
            
            # Update index
            self.index["report_count"] += 1
            
            if report_type not in self.index["reports_by_type"]:
                self.index["reports_by_type"][report_type] = []
            
            self.index["reports_by_type"][report_type].append(report_id)
            
            if agent_id not in self.index["reports_by_agent"]:
                self.index["reports_by_agent"][agent_id] = []
            
            self.index["reports_by_agent"][agent_id].append(report_id)
            
            self.index["reports"][report_id] = {
                "id": report_id,
                "title": title,
                "agent_id": agent_id,
                "report_type": report_type,
                "file_path": str(report_file),
                "generated_at": metadata["generated_at"],
                "metadata": metadata
            }
            
            # Save index
            self._save_index()
            
            logger.info(f"Report {report_id} of type {report_type} stored successfully in index")
            
            return report_id
        except Exception as e:
            logger.error(f"Critical error in store_report: {str(e)}", exc_info=True)
            return ""

    def get_report(self, report_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a report by ID.
        
        Args:
            report_id: ID of the report
            
        Returns:
            Report data or None if not found
        """
        if report_id not in self.index["reports"]:
            logger.warning(f"Report with ID {report_id} not found")
            return None
        
        report_info = self.index["reports"][report_id]
        
        try:
            with open(report_info["file_path"], 'r') as f:
                content = f.read()
            
            # Parse front matter and content
            if content.startswith("---"):
                end_front_matter = content.find("---", 3)
                if end_front_matter != -1:
                    front_matter = content[3:end_front_matter].strip()
                    content = content[end_front_matter + 3:].strip()
                    
                    # Parse front matter
                    metadata = {}
                    for line in front_matter.split("\n"):
                        if ": " in line:
                            key, value = line.split(": ", 1)
                            metadata[key] = value
            
            # Add content to report info
            report_data = report_info.copy()
            report_data["content"] = content
            
            return report_data
            
        except Exception as e:
            logger.error(f"Error retrieving report {report_id}: {str(e)}")
            return None
    
    def get_reports_by_type(self, report_type: str) -> List[Dict[str, Any]]:
        """
        Get all reports of a specific type.
        
        Args:
            report_type: Type of reports to retrieve
            
        Returns:
            List of report data
        """
        if report_type not in self.report_types:
            logger.warning(f"Unknown report type '{report_type}'")
            return []
        
        report_ids = self.index["reports_by_type"].get(report_type, [])
        reports = []
        
        for report_id in report_ids:
            report = self.get_report(report_id)
            if report:
                reports.append(report)
        
        return reports
    
    def get_reports_by_agent(self, agent_id: str) -> List[Dict[str, Any]]:
        """
        Get all reports generated by a specific agent.
        
        Args:
            agent_id: ID of the agent
            
        Returns:
            List of report data
        """
        report_ids = self.index["reports_by_agent"].get(agent_id, [])
        reports = []
        
        for report_id in report_ids:
            report = self.get_report(report_id)
            if report:
                reports.append(report)
        
        return reports
    
    def list_report_types(self) -> List[str]:
        """
        Get a list of all available report types.
        
        Returns:
            List of report types
        """
        return list(self.report_types.keys())
    
    def list_reports(self, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        List all reports in the system, optionally limited.
        
        Args:
            limit: Maximum number of reports to return
            
        Returns:
            List of report metadata
        """
        reports = list(self.index["reports"].values())
        
        # Sort by generation time (newest first)
        reports.sort(key=lambda r: r.get("generated_at", ""), reverse=True)
        
        if limit is not None:
            reports = reports[:limit]
        
        return reports